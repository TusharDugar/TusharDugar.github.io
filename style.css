// script.js

// Function to copy text to clipboard for contact buttons
function copyToClipboard(button) {
    const value = button.dataset.contact || ''; 

    if (value) {
        navigator.clipboard.writeText(value)
            .then(() => {
                button.classList.add('copied');
                setTimeout(() => {
                    button.classList.remove('copied');
                }, 2000);
            })
            .catch(err => {
                console.error('Failed to copy: ', err);
            });
    }
}

// Unified Function to reveal elements on scroll (Intersection Observer)
function initIntersectionObserverAnimations() {
  const observerOptions = { root: null, rootMargin: "0px", threshold: 0.1 };
  const observer = new IntersectionObserver((entries, observer) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
            entry.target.classList.add("visible");
            observer.unobserve(entry.target);
            return;
        }
        if (entry.target.classList.contains("reveal-item")) {
          entry.target.classList.add("visible");
        }
        else if (entry.target.classList.contains("reveal-parent")) {
          const childrenToStagger = entry.target.querySelectorAll(".reveal-child"); 
          childrenToStagger.forEach((child, index) => {
            setTimeout(() => { child.classList.add("visible"); }, index * 100);
          });
        }
        else if (entry.target.classList.contains("reveal-stagger-container")) {
          const children = entry.target.querySelectorAll(".reveal-stagger");
          children.forEach((child, index) => {
            setTimeout(() => { child.classList.add("visible"); }, index * 100);
          });
        }
        observer.unobserve(entry.target);
      }
    });
  }, observerOptions);
  document.querySelectorAll(".reveal-item, .reveal-parent, .reveal-stagger-container").forEach(el => observer.observe(el));
}

// Main execution block after DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    
    // Mouse Follower Glow
    const mouseFollowerGlow = document.querySelector('.mouse-follower-glow');
    if (mouseFollowerGlow) {
        document.addEventListener('mousemove', (event) => {
            gsap.to(mouseFollowerGlow, { x: event.clientX, y: event.clientY, duration: 0.3, ease: "power2.out" });
        });
    }

    // Initialize contact button functionality
    const contactButtons = document.querySelectorAll('.contact-button');
    contactButtons.forEach(button => {
        button.addEventListener('click', () => copyToClipboard(button));
    });

    // Initialize all other reveal-on-scroll animations
    initIntersectionObserverAnimations();

    // --- FINAL POLISHED SERVICES ANIMATION ---
    const servicesSection = document.getElementById('services'); // The outer <section>
    const servicesPinWrapper = document.getElementById('services-pin-wrapper'); // The div *inside* the section that holds heading and cube
    const servicesHeading = servicesSection ? servicesSection.querySelector('.services-heading') : null;
    const cubeContainer = servicesSection ? servicesSection.querySelector('.cube-container') : null;
    const cube = servicesSection ? document.getElementById('services-cube') : null;
    const faces = servicesSection ? servicesSection.querySelectorAll('.face') : null;
    const SERVICES_COUNT = faces ? faces.length : 0;

    if (!servicesSection || !servicesPinWrapper || !servicesHeading || !cubeContainer || !cube || SERVICES_COUNT === 0) {
        console.warn("One or more required services section elements not found. Aborting services animation setup.");
        return;
    }

    gsap.matchMedia().add({
        isDesktop: "(min-width: 769px)",
        isMobile: "(max-width: 768px)",
        reducedMotion: "(prefers-reduced-motion: reduce)"
    }, (context) => {
        let { isDesktop, reducedMotion } = context.conditions;

        // If not desktop or reduced motion, revert to static layout
        if (!isDesktop || reducedMotion) {
            gsap.set(faces, { position: 'relative', transform: 'none', autoAlpha: 1 });
            // Ensure cube container doesn't have absolute positioning applied by JS previously
            gsap.set(cubeContainer, { position: 'relative', top: 'auto', left: 'auto', x: 0 });
            return;
        }

        const faceHeight = 220; // Height of each service face
        // Calculate the depth needed for the faces to form a cylinder (or prism)
        const faceDepth = (faceHeight / 2) / Math.tan(Math.PI / SERVICES_COUNT); 
        
        // Initial setup for cube faces
        faces.forEach((face, i) => {
            const angle = i * (360 / SERVICES_COUNT);
            gsap.set(face, {
                rotationX: `${angle}deg`, // Use rotationX for the cube effect
                transformOrigin: `center center -${faceDepth}px` // Pivot point for rotation
            });
        });

        // Ensure the cube-container itself is positioned absolutely within the services-pin-wrapper
        // so it can stay fixed relative to the viewport while the pin wrapper creates scroll space.
        gsap.set(cubeContainer, {
            position: 'absolute',
            top: '50%', // Vertically center within the available space below the heading
            left: '50%',
            x: '-50%', // Adjust for horizontal centering
            y: '-50%', // Adjust for vertical centering
            width: '100%',
            maxWidth: '800px',
            height: `${faceHeight}px` // Explicitly set height
        });

        // Determine the total rotation for the cube
        // We want to rotate to show all faces from 01 to 08
        const totalRotation = (SERVICES_COUNT) * (360 / SERVICES_COUNT); // e.g., 8 * 45 = 360 degrees

        // Calculate scroll length: A base minimum + height for each face to animate + some buffer
        const minScrollLength = window.innerHeight * 1.5; // Minimum scroll space
        const animationScrollDuration = SERVICES_COUNT * window.innerHeight * 0.7; // Duration for the animation itself
        servicesPinWrapper.style.height = `${minScrollLength + animationScrollDuration}px`;

        // Create the ScrollTrigger timeline
        let tl = gsap.timeline({
            scrollTrigger: {
                trigger: servicesPinWrapper,
                start: "top top", // Pin starts when the top of servicesPinWrapper hits the top of the viewport
                end: "bottom bottom", // Pin ends when the bottom of servicesPinWrapper leaves the bottom of the viewport
                scrub: 1, // Smoothly scrub the animation
                pin: servicesSection, // Pin the entire services section
                anticipatePin: 1,
                // markers: true // Uncomment for debugging
            }
        });

        // Tween for the cube's rotation
        // We rotate it by the total angle, so each face comes into view sequentially
        tl.to(cube, {
            rotationX: `+=${totalRotation}deg`, // Rotate in a positive direction (01 to 08)
            ease: "none",
        }, 0); // Start at the beginning of the timeline

        // Optional: Fade out and scale down the cube towards the end of the pinning
        tl.to(cubeContainer, {
            autoAlpha: 0,
            scale: 0.9,
            ease: "power1.in",
        }, 0.8); // Start this tween when 80% of the main animation is complete

    });

    window.addEventListener("resize", () => {
        ScrollTrigger.refresh(); // Important for responsive layouts and re-calculating pin positions
    });
});
